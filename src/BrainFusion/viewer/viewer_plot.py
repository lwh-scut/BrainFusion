import sys

import mne
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QFileDialog, QComboBox, QListWidget, QListWidgetItem,
    QLabel, QDialog, QFormLayout, QLineEdit, QSpinBox, QMessageBox, QInputDialog, QScrollArea, QCheckBox,
    QTableWidgetItem, QTableWidget
)
from PyQt5.QtCore import Qt, pyqtSignal

from BrainFusion.io.File_IO import read_xlsx
from BrainFusion.utils.normalize import min_max_scaling_to_range, min_max_scaling_by_arrays
from BrainFusion.utils.transform import read_info
from UI.ui_component import BFPushButton


def feature_dict_to_dataframe(feature_dict):
    """
    Convert feature dictionary to pandas DataFrame with Type column last.

    :param feature_dict: Dictionary generated by read_xlsx function
    :type feature_dict: dict
    :return: Processed DataFrame
    :rtype: pd.DataFrame
    """
    # Extract channel names
    ch_names = feature_dict["ch_names"]
    type_value = feature_dict["type"]  # Type is unique value

    # Create data dictionary without Type initially
    data = {"Channel": ch_names}

    # Add feature columns
    for feature, values in feature_dict["feature"].items():
        data[feature] = values

    # Create DataFrame
    df = pd.DataFrame(data)

    # Add Type column at end
    df["Type"] = type_value

    return df


def get_selected_data(feature_dict, selected_channels, selected_features):
    """
    Extract data for selected channels and features.

    :param feature_dict: Dictionary from read_xlsx
    :type feature_dict: dict
    :param selected_channels: List of selected channels
    :type selected_channels: list[str]
    :param selected_features: List of selected features
    :type selected_features: list[str]
    :return: Data dictionary with selected channels/features
    :rtype: dict
    """
    selected_data = {}

    # Get channel indices
    channel_indices = [i for i, ch in enumerate(feature_dict['ch_names']) if ch in selected_channels]

    # Filter each feature
    for feature in selected_features:
        if feature not in feature_dict['feature']:
            continue

        # Filter data for selected channels
        selected_data[feature] = []
        for idx in channel_indices:
            selected_data[feature].append(feature_dict['feature'][feature][idx])

    return selected_data


class SelectItemsDialog(QDialog):
    """Dialog for selecting items with checkboxes."""

    def __init__(self, items, title, selected_items=None, parent=None):
        """
        Initialize item selection dialog.

        :param items: Items to display
        :type items: list[str]
        :param title: Window title
        :type title: str
        :param selected_items: Pre-selected items
        :type selected_items: list[str]
        :param parent: Parent widget
        :type parent: QWidget
        """
        super().__init__(parent)
        self.setWindowTitle(title)
        self.items = items
        self.selected_items = selected_items if selected_items else []
        self.init_ui()

    def init_ui(self):
        """Initialize user interface components."""
        layout = QVBoxLayout()
        self.checkboxes = []

        # Create checkboxes for each item
        for item in self.items:
            checkbox = QCheckBox(item)
            checkbox.setChecked(item in self.selected_items)
            self.checkboxes.append(checkbox)
            layout.addWidget(checkbox)

        # Add buttons
        hlayout = QHBoxLayout()
        self.select_all_button = QPushButton("Select All")
        self.select_all_button.clicked.connect(self.select_all)
        hlayout.addWidget(self.select_all_button)
        self.confirm_button = QPushButton("Confirm")
        self.confirm_button.clicked.connect(self.accept)
        hlayout.addWidget(self.confirm_button)
        layout.addLayout(hlayout)
        self.setLayout(layout)

    def select_all(self):
        """Toggle select/deselect all items."""
        if self.select_all_button.isChecked():
            for checkbox in self.checkboxes:
                checkbox.setChecked(False)
        else:
            for checkbox in self.checkboxes:
                checkbox.setChecked(True)

    def get_selected_items(self):
        """
        Get selected items.

        :return: List of selected items
        :rtype: list[str]
        """
        self.selected_items = [checkbox.text() for checkbox in self.checkboxes if checkbox.isChecked()]
        return self.selected_items


class PlotCanvas(FigureCanvas):
    """Base canvas for plotting features."""

    def __init__(self, parent=None, width=8, height=6, dpi=100):
        """
        Initialize plotting canvas.

        :param parent: Parent widget
        :type parent: QWidget
        :param width: Figure width
        :type width: int
        :param height: Figure height
        :type height: int
        :param dpi: Figure DPI
        :type dpi: int
        """
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)
        self.ax = self.fig.add_subplot(111)

    def plot(self, df, selected_channels, selected_features, plot_type, settings):
        """
        Plot data with selected visualization.

        :param df: DataFrame to plot
        :type df: pd.DataFrame
        :param selected_channels: Selected channels
        :type selected_channels: list[str]
        :param selected_features: Selected features
        :type selected_features: list[str]
        :param plot_type: Plot type ("曲线图"/"柱状图")
        :type plot_type: str
        :param settings: Plot settings
        :type settings: dict
        """
        self.ax.clear()  # Clear previous plot
        if plot_type == "曲线图":  # Line plot
            x_labels = selected_features
            for channel in selected_channels:
                # Get channel data for selected features
                data = [
                    df.loc[df.iloc[:, 0] == channel, feature].values[0] if not df.loc[
                        df.iloc[:, 0] == channel, feature].empty else None
                    for feature in selected_features
                ]
                self.ax.plot(x_labels, data, marker='o', label=channel)

            self.ax.set_xticks(range(len(x_labels)))
            self.ax.set_xticklabels(x_labels, rotation=45, ha="right")

        elif plot_type == "柱状图":  # Bar plot
            x_indices = range(len(selected_channels))
            bar_width = 0.8 / len(selected_features)
            for i, feature in enumerate(selected_features):
                # Calculate mean values
                values = [
                    df[df.iloc[:, 0] == channel][feature].mean()
                    for channel in selected_channels
                ]
                positions = [x + i * bar_width for x in x_indices]
                self.ax.bar(positions, values, bar_width, label=feature)

            self.ax.set_xticks([x + (len(selected_features) - 1) * bar_width / 2 for x in x_indices])
            self.ax.set_xticklabels(selected_channels)

        # Apply settings
        self.ax.set_title(settings.get("title", ""))
        self.ax.set_xlabel(settings.get("xlabel", ""))
        self.ax.set_ylabel(settings.get("ylabel", ""))
        self.ax.legend()
        self.draw()


class BarPlotCanvas(FigureCanvas):
    """Canvas for bar plot visualization."""

    def __init__(self, parent=None, width=8, height=6, dpi=100):
        """
        Initialize bar plot canvas.

        :param parent: Parent widget
        :type parent: QWidget
        :param width: Figure width
        :type width: int
        :param height: Figure height
        :type height: int
        :param dpi: Figure DPI
        :type dpi: int
        """
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)
        self.ax = self.fig.add_subplot(111)

    def plot(self, data, selected_channels, selected_features, settings):
        """
        Create bar plot visualization.

        :param data: Input data dictionary
        :type data: dict
        :param selected_channels: Selected channels
        :type selected_channels: list[str]
        :param selected_features: Selected features
        :type selected_features: list[str]
        :param settings: Plot settings
        :type settings: dict
        """
        self.ax.clear()
        x_indices = range(len(selected_channels))
        bar_width = 0.8 / len(selected_features)

        # Get filtered data
        select_data = get_selected_data(data, selected_channels, selected_features)
        for i, feature in enumerate(selected_features):
            values = select_data[feature]
            positions = [x + i * bar_width for x in x_indices]
            self.ax.bar(positions, values, bar_width, label=feature)

        self.ax.set_xticks([x + (len(selected_features) - 1) * bar_width / 2 for x in x_indices])
        self.ax.set_xticklabels(selected_channels)
        self.ax.set_title(settings.get("title", ""))
        self.ax.set_xlabel(settings.get("xlabel", ""))
        self.ax.set_ylabel(settings.get("ylabel", ""))
        self.ax.legend()
        self.draw()


class TablePlotCanvas(QTableWidget):
    """Widget for tabular data display."""

    def __init__(self, parent=None):
        """
        Initialize table widget.

        :param parent: Parent widget
        :type parent: QWidget
        """
        super().__init__(parent)
        self.horizontalHeader().setDefaultSectionSize(200)
        self.resizeColumnsToContents()
        self.resizeRowsToContents()

    def plot(self, df):
        """
        Display data in table format.

        :param df: DataFrame to display
        :type df: pd.DataFrame
        """
        self.clear()
        self.setRowCount(len(df))
        self.setColumnCount(len(df.columns))
        self.setHorizontalHeaderLabels(df.columns)

        # Populate table
        for i in range(len(df)):
            for j in range(len(df.columns)):
                item = QTableWidgetItem(str(df.iloc[i, j]))
                self.setItem(i, j, item)


class CurvePlotCanvas(FigureCanvas):
    """Canvas for curve plot visualization."""

    def __init__(self, parent=None, width=8, height=6, dpi=100):
        """
        Initialize curve plot canvas.

        :param parent: Parent widget
        :type parent: QWidget
        :param width: Figure width
        :type width: int
        :param height: Figure height
        :type height: int
        :param dpi: Figure DPI
        :type dpi: int
        """
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)
        self.ax = self.fig.add_subplot(111)

    def plot(self, data, selected_channels, selected_features, settings):
        """
        Create curve plot visualization.

        :param data: Input data dictionary
        :type data: dict
        :param selected_channels: Selected channels
        :type selected_channels: list[str]
        :param selected_features: Selected features
        :type selected_features: list[str]
        :param settings: Plot settings
        :type settings: dict
        """
        self.ax.clear()
        x_labels = selected_features

        # Filter and process data
        select_data = get_selected_data(data, selected_channels, selected_features)
        select_channel_data = []
        for feature in selected_features:
            select_channel_data.append(select_data[feature])
        select_channel_data = np.array(select_channel_data).T

        # Plot each channel
        for i, channel in enumerate(selected_channels):
            chan_data = select_channel_data[i]
            self.ax.plot(x_labels, chan_data, marker='o', label=channel)

        self.ax.set_xticks(range(len(x_labels)))
        self.ax.set_xticklabels(x_labels, rotation=45, ha="right")
        self.ax.set_title(settings.get("title", ""))
        self.ax.set_xlabel(settings.get("xlabel", ""))
        self.ax.set_ylabel(settings.get("ylabel", ""))
        self.ax.legend()
        self.draw()


class TopomapCanvas(FigureCanvas):
    """Canvas for topographic map visualization."""

    def __init__(self, parent=None, width=8, height=6, dpi=100):
        """
        Initialize topomap canvas.

        :param parent: Parent widget
        :type parent: QWidget
        :param width: Figure width
        :type width: int
        :param height: Figure height
        :type height: int
        :param dpi: Figure DPI
        :type dpi: int
        """
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)

    def plot(self, data, info_dict, selected_channels, selected_features, is_relative=False, is_show_sensor=False):
        """
        Create topographic map visualization.

        :param data: Input data dictionary
        :type data: dict
        :param info_dict: Montage/sensor information
        :type info_dict: dict
        :param selected_channels: Selected channels
        :type selected_channels: list[str]
        :param selected_features: Selected features
        :type selected_features: list[str]
        :param is_relative: Use relative scaling
        :type is_relative: bool
        :param is_show_sensor: Display sensor locations
        :type is_show_sensor: bool
        """
        if not data:
            return

        num_fig = len(selected_features)
        self.axes = self.fig.subplots(1, num_fig, sharex=True, sharey=True)

        # Get filtered data
        select_data = get_selected_data(data, selected_channels, selected_features)
        select_channel_data = []
        for feature in selected_features:
            select_channel_data.append(select_data[feature])
        select_channel_data = np.array(select_channel_data)

        # Scale data
        if is_relative:
            norm_data = min_max_scaling_to_range(select_channel_data)
            data_range = (-1, 1)
        else:
            norm_data = min_max_scaling_by_arrays(select_channel_data)
            data_range = (-1, 1)

        # Create montage if available
        if 'montage' in info_dict.keys():
            montage = mne.channels.make_standard_montage(info_dict['montage'])
            info = mne.create_info(ch_names=selected_channels, sfreq=info_dict['srate'], ch_types='eeg')

            # Plot each feature
            for i, psd in enumerate(norm_data):
                evoked = mne.EvokedArray(data=select_channel_data.T, info=info)
                evoked.set_montage(montage)
                self.axes[i].clear()
                self.axes[i].set_title(selected_features[i])

                # Plot with/without sensors
                if is_show_sensor:
                    mne.viz.plot_topomap(psd, evoked.info, axes=self.axes[i],
                                         show=False, sensors=True, vlim=data_range, names=selected_channels)
                else:
                    mne.viz.plot_topomap(psd, evoked.info, axes=self.axes[i],
                                         show=False, sensors=False, vlim=data_range, names=None)
                self.axes[i].figure.canvas.draw()

        # Handle other cases (loc in info_dict, etc.)
        elif 'loc' in info_dict.keys():
            pass  # Implement custom location handling if needed


class PlotSettingsDialog(QWidget):
    """Dialog for configuring plot settings."""
    closed_signal = pyqtSignal()

    def __init__(self, parent=None, initial_settings=None):
        """
        Initialize plot settings dialog.

        :param parent: Parent widget
        :type parent: QWidget
        :param initial_settings: Initial settings values
        :type initial_settings: dict
        """
        super().__init__(parent)
        self.setWindowTitle("Plot Settings")
        self.resize(300, 200)
        self.layout = QVBoxLayout()
        self.init_ui(initial_settings)

    def init_ui(self, initial_settings):
        """Initialize settings UI components."""
        self.form_layout = QFormLayout()

        # Create input fields
        self.title_input = QLineEdit()
        self.xlabel_input = QLineEdit()
        self.ylabel_input = QLineEdit()
        self.width_input = QSpinBox()
        self.width_input.setRange(1, 50)
        self.height_input = QSpinBox()
        self.height_input.setRange(1, 50)

        # Set initial values
        if initial_settings:
            self.title_input.setText(initial_settings.get("title", ""))
            self.xlabel_input.setText(initial_settings.get("xlabel", ""))
            self.ylabel_input.setText(initial_settings.get("ylabel", ""))
            self.width_input.setValue(initial_settings.get("width", 8))
            self.height_input.setValue(initial_settings.get("height", 6))
        else:
            self.width_input.setValue(8)
            self.height_input.setValue(6)

        # Add rows
        self.form_layout.addRow("Title:", self.title_input)
        self.form_layout.addRow("X Label:", self.xlabel_input)
        self.form_layout.addRow("Y Label:", self.ylabel_input)
        self.form_layout.addRow("Width:", self.width_input)
        self.form_layout.addRow("Height:", self.height_input)

        # Add save button
        self.layout.addLayout(self.form_layout)
        self.save_button = QPushButton("Save Settings")
        self.save_button.clicked.connect(self.close)
        self.layout.addWidget(self.save_button)
        self.setLayout(self.layout)

    def get_settings(self):
        """
        Get current settings values.

        :return: Dictionary of settings
        :rtype: dict
        """
        return {
            "title": self.title_input.text(),
            "xlabel": self.xlabel_input.text(),
            "ylabel": self.ylabel_input.text(),
            "width": self.width_input.value(),
            "height": self.height_input.value()
        }

    def closeEvent(self, event):
        """
        Handle dialog closing.

        :param event: Close event
        :type event: QEvent
        """
        self.closed_signal.emit()
        event.accept()


class MainWindow(QMainWindow):
    """Main application window for feature plotting."""

    def __init__(self):
        """Initialize main window components."""
        super().__init__()
        self.setWindowTitle("Feature Plotting Tool")
        self.resize(800, 600)
        self.df = None
        self.channels = []
        self.features = []
        self.settings = {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""}
        self.init_ui()

    def init_ui(self):
        """Initialize user interface components."""
        # Main widget and layout
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QVBoxLayout(main_widget)

        # File loading controls
        self.load_button = QPushButton("Load File")
        self.load_button.clicked.connect(self.load_file)
        main_layout.addWidget(self.load_button)

        # Channel selection
        channel_layout = QHBoxLayout()
        self.channel_button = QPushButton("Select Channels")
        self.channel_button.clicked.connect(self.select_channels)
        self.channel_lineedit = QLineEdit()
        channel_layout.addWidget(self.channel_button)
        channel_layout.addWidget(self.channel_lineedit)
        main_layout.addLayout(channel_layout)

        # Feature selection
        feature_layout = QHBoxLayout()
        self.feature_button = QPushButton("Select Features")
        self.feature_button.clicked.connect(self.select_features)
        self.feature_lineedit = QLineEdit()
        feature_layout.addWidget(self.feature_button)
        feature_layout.addWidget(self.feature_lineedit)
        main_layout.addLayout(feature_layout)

        # Plot type selection
        main_layout.addWidget(QLabel("Select Plot Type:"))
        self.plot_type_combo = QComboBox()
        self.plot_type_combo.addItems(["Line Plot", "Bar Plot", "Data Table"])
        self.plot_type_combo.currentIndexChanged.connect(self.update_plot_area)
        main_layout.addWidget(self.plot_type_combo)

        # Settings button
        self.settings_button = QPushButton("Plot Settings")
        self.settings_dialog = PlotSettingsDialog()
        self.settings_dialog.save_button.clicked.connect(self.save_settings)
        self.settings_button.clicked.connect(self.settings_dialog.show)
        main_layout.addWidget(self.settings_button)

        # Visualization area
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(False)
        main_layout.addWidget(self.scroll_area)

        # Canvas container
        canvas_container = QWidget()
        self.canvas_layout = QVBoxLayout(canvas_container)
        self.canvas = PlotCanvas(self, width=8, height=6)
        self.canvas_layout.addWidget(self.canvas)
        self.scroll_area.setWidget(canvas_container)
        self.table = QTableWidget()

        # Action buttons
        button_layout = QHBoxLayout()
        self.plot_button = QPushButton("Generate Plot")
        self.plot_button.clicked.connect(self.plot)
        button_layout.addWidget(self.plot_button)
        self.save_button = QPushButton("Save Visualization")
        self.save_button.clicked.connect(self.save_plot)
        button_layout.addWidget(self.save_button)
        main_layout.addLayout(button_layout)

    def update_plot_area(self):
        """Update visualization area based on plot type."""
        plot_type = self.plot_type_combo.currentText()
        if plot_type == "Data Table":
            self.scroll_area.setWidget(self.table)
            self.scroll_area.setWidgetResizable(True)
            if self.df is not None:
                self.load_data_to_table()
        else:
            self.canvas = PlotCanvas(self, width=8, height=6)
            self.scroll_area.setWidget(self.canvas)
            self.scroll_area.setWidgetResizable(False)

    def load_data_to_table(self):
        """Load data into table widget."""
        if self.df is None:
            QMessageBox.warning(self, "Warning", "Please load data file first!")
            return

        self.table.clear()
        self.table.setRowCount(len(self.df))
        self.table.setColumnCount(len(self.df.columns))
        self.table.setHorizontalHeaderLabels(self.df.columns)

        for i in range(len(self.df)):
            for j in range(len(self.df.columns)):
                item = QTableWidgetItem(str(self.df.iloc[i, j]))
                self.table.setItem(i, j, item)

    def save_table_to_dataframe(self):
        """Save table data back to DataFrame."""
        if self.table.isVisible():
            row_count = self.table.rowCount()
            col_count = self.table.columnCount()
            data = []
            for i in range(row_count):
                row = []
                for j in range(col_count):
                    item = self.table.item(i, j)
                    row.append(item.text() if item else "")
                data.append(row)
            self.df = pd.DataFrame(data, columns=self.df.columns)

    def load_file(self):
        """Load data file from dialog."""
        file_path, _ = QFileDialog.getOpenFileName(self, "Load Data File", "", "Excel Files (*.xlsx)")
        if not file_path:
            return

        try:
            # Read and process file
            self.df = pd.read_excel(file_path)
            self.channels = self.df.iloc[:, 0].unique()
            self.features = [col for col in self.df.columns[1:] if col != "Type"]
            self.channel_lineedit.clear()
            self.feature_lineedit.clear()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"File loading failed: {str(e)}")

    def select_channels(self):
        """Open channel selection dialog."""
        dialog = SelectItemsDialog(self.channels, "Select Channels")
        if dialog.exec_() == QDialog.Accepted:
            selected_channels = dialog.get_selected_items()
            self.channel_lineedit.setText(", ".join(selected_channels))

    def select_features(self):
        """Open feature selection dialog."""
        dialog = SelectItemsDialog(self.features, "Select Features")
        if dialog.exec_() == QDialog.Accepted:
            selected_features = dialog.get_selected_items()
            self.feature_lineedit.setText(", ".join(selected_features))

    def save_settings(self):
        """Save current plot settings."""
        self.settings = self.settings_dialog.get_settings()

    def plot(self):
        """Generate visualization based on selections."""
        if self.df is None:
            QMessageBox.warning(self, "Warning", "Please load data file first!")
            return

        # Get selections
        selected_channels = self.channel_lineedit.text().split(", ")
        selected_features = self.feature_lineedit.text().split(", ")
        plot_type = self.plot_type_combo.currentText()

        if not selected_channels or not selected_features:
            QMessageBox.warning(self, "Warning", "Select channels and features!")
            return

        settings = getattr(self, 'settings', {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""})
        width = settings.get("width", 8)
        height = settings.get("height", 6)

        # Prepare canvas
        self.canvas = PlotCanvas(self, width=width, height=height)
        self.scroll_area.setWidget(self.canvas)
        self.canvas.fig.set_size_inches(width, height, forward=True)

        # Create visualization
        self.canvas.plot(self.df, selected_channels, selected_features, plot_type, settings)

    def save_plot(self):
        """Save current visualization to file."""
        if self.plot_type_combo.currentText() == "Data Table":
            # Handle table saving
            file_path, _ = QFileDialog.getSaveFileName(self, "Save Table", "", "Excel Files (*.xlsx);;All Files (*)")
            if not file_path:
                return
            try:
                self.save_table_to_dataframe()
                self.df.to_excel(file_path, index=False)
                QMessageBox.information(self, "Success", f"Table saved to {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Table save failed: {str(e)}")
        else:
            # Handle plot saving
            if not self.canvas.fig.axes:
                QMessageBox.warning(self, "Warning", "Generate plot first!")
                return

            file_path, _ = QFileDialog.getSaveFileName(self, "Save Plot", "",
                                                       "PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)")
            if not file_path:
                return

            dpi, ok = QInputDialog.getInt(self, "Set DPI", "Enter DPI value:", value=300, min=50, max=600)
            if ok:
                try:
                    self.canvas.fig.savefig(file_path, dpi=dpi)
                    QMessageBox.information(self, "Success", f"Plot saved to {file_path}")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Plot save failed: {str(e)}")

    def clear_layout(self, layout):
        """
        Clear widgets from layout.

        :param layout: Layout to clear
        :type layout: QLayout
        """
        for i in range(layout.count()):
            item = layout.itemAt(i)
            widget = item.widget()
            if widget:
                widget.deleteLater()


class FeaturePlotWidget(QWidget):
    """Base widget for feature visualization."""

    def __init__(self, data, channels, features):
        """
        Initialize feature plotting widget.

        :param data: Data dictionary
        :type data: dict
        :param channels: Available channels
        :type channels: list[str]
        :param features: Available features
        :type features: list[str]
        """
        super().__init__()
        self.resize(800, 600)
        self.data = data
        self.channels = channels
        self.features = features
        self.settings = {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""}
        self.init_ui()

    def init_ui(self):
        """Initialize UI components."""
        self.main_layout = QVBoxLayout(self)

        # Channel selection
        channel_layout = QHBoxLayout()
        self.channel_button = BFPushButton("Select Channels")
        self.channel_button.clicked.connect(self.select_channels)
        self.channel_lineedit = QLineEdit()
        channel_layout.addWidget(self.channel_button)
        channel_layout.addWidget(self.channel_lineedit)
        self.main_layout.addLayout(channel_layout)

        # Feature selection
        feature_layout = QHBoxLayout()
        self.feature_button = BFPushButton("Select Features")
        self.feature_button.clicked.connect(self.select_features)
        self.feature_lineedit = QLineEdit()
        feature_layout.addWidget(self.feature_button)
        feature_layout.addWidget(self.feature_lineedit)
        self.main_layout.addLayout(feature_layout)

        # Middle layout (for subclass extension)
        self.mid_layout = QHBoxLayout()
        self.main_layout.addLayout(self.mid_layout)

        # Action buttons
        button_layout = QHBoxLayout()
        self.plot_button = BFPushButton("Generate Plot")
        self.plot_button.setFixedWidth(120)
        self.plot_button.clicked.connect(self.plot)
        button_layout.addWidget(self.plot_button)
        self.save_button = BFPushButton("Save Plot")
        self.save_button.setFixedWidth(120)
        self.save_button.clicked.connect(self.save_plot)
        button_layout.addWidget(self.save_button)
        button_layout.addStretch(1)
        self.settings_button = BFPushButton("Configure Settings")
        self.settings_button.setFixedWidth(120)
        self.settings_dialog = PlotSettingsDialog()
        self.settings_dialog.save_button.clicked.connect(self.save_settings)
        self.settings_button.clicked.connect(self.settings_dialog.show)
        button_layout.addWidget(self.settings_button)
        self.main_layout.addLayout(button_layout)

        # Visualization area
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(False)
        self.main_layout.addWidget(self.scroll_area)

    def select_channels(self):
        """Open channel selection dialog."""
        dialog = SelectItemsDialog(self.channels, "Select Channels")
        if dialog.exec_() == QDialog.Accepted:
            selected_channels = dialog.get_selected_items()
            self.channel_lineedit.setText(", ".join(selected_channels))

    def select_features(self):
        """Open feature selection dialog."""
        dialog = SelectItemsDialog(self.features, "Select Features")
        if dialog.exec_() == QDialog.Accepted:
            selected_features = dialog.get_selected_items()
            self.feature_lineedit.setText(", ".join(selected_features))

    def save_settings(self):
        """Save current plot settings."""
        self.settings = self.settings_dialog.get_settings()

    def plot(self):
        """Generate visualization (to be implemented by subclasses)."""
        pass

    def save_plot(self):
        """Save visualization (to be implemented by subclasses)."""
        pass

    def clear_layout(self, layout):
        """
        Clear widgets from layout.

        :param layout: Layout to clear
        :type layout: QLayout
        """
        for i in range(layout.count()):
            item = layout.itemAt(i)
            widget = item.widget()
            if widget:
                widget.deleteLater()


class CurvePlotWidget(FeaturePlotWidget):
    """Widget for curve plot visualization."""

    def __init__(self, data, channels, features):
        """
        Initialize curve plot widget.

        :param data: Data dictionary
        :type data: dict
        :param channels: Available channels
        :type channels: list[str]
        :param features: Available features
        :type features: list[str]
        """
        super().__init__(data, channels, features)
        self.canvas = CurvePlotCanvas()
        self.scroll_area.setWidget(self.canvas)

    def plot(self):
        """Generate curve plot visualization."""
        if not self.data:
            QMessageBox.warning(self, "Warning", "Load data first!")
            return

        # Get selections
        selected_channels = self.channel_lineedit.text().split(", ")
        selected_features = self.feature_lineedit.text().split(", ")

        if not selected_channels or not selected_features:
            QMessageBox.warning(self, "Warning", "Select channels and features!")
            return

        settings = getattr(self, 'settings', {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""})
        width = settings.get("width", 8)
        height = settings.get("height", 6)

        # Update canvas
        self.canvas = CurvePlotCanvas(self, width=width, height=height)
        self.scroll_area.setWidget(self.canvas)
        self.canvas.fig.set_size_inches(width, height, forward=True)
        self.canvas.plot(self.data, selected_channels, selected_features, settings)

    def save_plot(self):
        """Save curve plot to file."""
        if not self.canvas.fig.axes:
            QMessageBox.warning(self, "Warning", "Generate plot first!")
            return

        file_path, _ = QFileDialog.getSaveFileName(self, "Save Figure", "",
                                                   "PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)")
        if not file_path:
            return

        dpi, ok = QInputDialog.getInt(self, "Set DPI", "Enter DPI value (default 300):", value=300, min=50, max=600)
        if ok:
            try:
                self.canvas.fig.savefig(file_path, dpi=dpi)
                QMessageBox.information(self, "Success", f"Plot saved to {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Save failed: {str(e)}")


class BarPlotWidget(FeaturePlotWidget):
    """Widget for bar plot visualization."""

    def __init__(self, data, channels, features):
        """
        Initialize bar plot widget.

        :param data: Data dictionary
        :type data: dict
        :param channels: Available channels
        :type channels: list[str]
        :param features: Available features
        :type features: list[str]
        """
        super().__init__(data, channels, features)
        self.canvas = BarPlotCanvas()
        self.scroll_area.setWidget(self.canvas)

    def plot(self):
        """Generate bar plot visualization."""
        if not self.data:
            QMessageBox.warning(self, "Warning", "Load data first!")
            return

        # Get selections
        selected_channels = self.channel_lineedit.text().split(", ")
        selected_features = self.feature_lineedit.text().split(", ")

        if not selected_channels or not selected_features:
            QMessageBox.warning(self, "Warning", "Select channels and features!")
            return

        settings = getattr(self, 'settings', {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""})
        width = settings.get("width", 8)
        height = settings.get("height", 6)

        # Update canvas
        self.canvas = BarPlotCanvas(self, width=width, height=height)
        self.scroll_area.setWidget(self.canvas)
        self.canvas.fig.set_size_inches(width, height, forward=True)
        self.canvas.plot(self.data, selected_channels, selected_features, settings)

    def save_plot(self):
        """Save bar plot to file."""
        if not self.canvas.fig.axes:
            QMessageBox.warning(self, "Warning", "Generate plot first!")
            return

        file_path, _ = QFileDialog.getSaveFileName(self, "Save Figure", "",
                                                   "PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)")
        if not file_path:
            return

        dpi, ok = QInputDialog.getInt(self, "Set DPI", "Enter DPI value (default 300):", value=300, min=50, max=600)
        if ok:
            try:
                self.canvas.ffig.savefig(file_path, dpi=dpi)
                QMessageBox.information(self, "Success", f"Plot saved to {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Save failed: {str(e)}")


class TablePlotWidget(FeaturePlotWidget):
    """Widget for tabular data display."""

    def __init__(self, data, channels, features):
        """
        Initialize table plot widget.

        :param data: Data dictionary
        :type data: dict
        :param channels: Available channels
        :type channels: list[str]
        :param features: Available features
        :type features: list[str]
        """
        super().__init__(data, channels, features)
        self.canvas = TablePlotCanvas()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setWidget(self.canvas)
        # Hide unnecessary controls
        self.feature_button.setVisible(False)
        self.feature_lineedit.setVisible(False)
        self.channel_button.setVisible(False)
        self.channel_lineedit.setVisible(False)
        self.settings_button.setVisible(False)

    def plot(self):
        """Display data in table format."""
        data = feature_dict_to_dataframe(self.data)
        self.canvas.plot(data)

    def save_plot(self):
        """Save table data to file."""
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Table", "", "Excel Files (*.xlsx);;All Files (*)")
        if not file_path:
            return
        try:
            self.data.to_excel(file_path, index=False)
            QMessageBox.information(self, "Success", f"Table saved to {file_path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Save failed: {str(e)}")


class TopoMapPlotWidget(FeaturePlotWidget):
    """Widget for topographic map visualization."""

    def __init__(self, data, channels, features):
        """
        Initialize topomap plot widget.

        :param data: Data dictionary
        :type data: dict
        :param channels: Available channels
        :type channels: list[str]
        :param features: Available features
        :type features: list[str]
        """
        super().__init__(data, channels, features)
        self.canvas = TopomapCanvas()
        self.scroll_area.setWidget(self.canvas)
        self.info = None

        # Info selection controls
        self.info_select_button = BFPushButton('Select Info File')
        self.info_select_button.setFixedWidth(120)
        self.info_select_lineedit = QLineEdit()
        self.mid_layout.addWidget(self.info_select_button)
        self.mid_layout.addWidget(self.info_select_lineedit)
        self.info_select_button.clicked.connect(self.select_info_json)

        # Visualization options
        self.bottom_layout = QHBoxLayout()
        self.relative_checkbox = QCheckBox('Relative Scaling')
        self.show_sensor_checkbox = QCheckBox('Show Sensors')
        self.bottom_layout.addWidget(self.relative_checkbox)
        self.bottom_layout.addWidget(self.show_sensor_checkbox)
        self.bottom_layout.addStretch(1)
        self.main_layout.addLayout(self.bottom_layout)

    def select_info_json(self):
        """Select sensor information file."""
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Info File", "", "JSON Files (*.json)")
        if file_path:
            self.info = read_info(file_path)
            self.info_select_lineedit.setText(file_path)

    def plot(self):
        """Generate topographic map visualization."""
        if not self.data:
            QMessageBox.warning(self, "Warning", "Load data first!")
            return

        # Get selections
        selected_channels = self.channel_lineedit.text().split(", ")
        selected_features = self.feature_lineedit.text().split(", ")

        if not selected_channels or not selected_features:
            QMessageBox.warning(self, "Warning", "Select channels and features!")
            return

        settings = getattr(self, 'settings', {"width": 8, "height": 6, "title": "", "xlabel": "", "ylabel": ""})
        width = settings.get("width", 8)
        height = settings.get("height", 6)

        # Update canvas
        self.canvas = TopomapCanvas(self, width=width, height=height)
        self.scroll_area.setWidget(self.canvas)
        is_relative = self.relative_checkbox.isChecked()
        is_show_sensor = self.show_sensor_checkbox.isChecked()

        # Create visualization
        if self.info:
            self.canvas.plot(self.data, self.info, selected_channels, selected_features,
                             is_relative, is_show_sensor)
        else:
            QMessageBox.warning(self, "Warning", "Select info file first!")

    def save_plot(self):
        """Save topographic map to file."""
        if not self.canvas.fig.axes:
            QMessageBox.warning(self, "Warning", "Generate plot first!")
            return

        file_path, _ = QFileDialog.getSaveFileName(self, "Save Figure", "",
                                                   "PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)")
        if not file_path:
            return

        dpi, ok = QInputDialog.getInt(self, "Set DPI", "Enter DPI value (default 300):", value=300, min=50, max=600)
        if ok:
            try:
                self.canvas.fig.savefig(file_path, dpi=dpi)
                QMessageBox.information(self, "Success", f"Plot saved to {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Save failed: {str(e)}")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    data = read_xlsx('C:\\Users\\28164\\Desktop\\test\\open_dataset\\MI_1_eeg_psd.xlsx')
    select_data = get_selected_data(data, ['F7', 'AFF5h', 'F3'], ['Delta', 'Beta'])
    print(select_data)
    sys.exit(app.exec())